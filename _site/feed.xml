<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The dantou&#39;s blog</title>
    <description>Welcome to the dantou&#39;s blog!
</description>
    <link>http://blog.dantou.cc/</link>
    <atom:link href="http://blog.dantou.cc/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 28 Apr 2016 23:43:02 +0800</pubDate>
    <lastBuildDate>Thu, 28 Apr 2016 23:43:02 +0800</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>LeetCode---maximum-depth-of-binary-tree</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;题目描述&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-1&quot;&gt;程序代码&lt;/h1&gt;

&lt;h2 id=&quot;section-2&quot;&gt;1.递归&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
	
		TreeNode(int x) {
			val = x;
		}
	}

	public int maxDepth(TreeNode root) {

		if (root == null) {
			return 0;
		}

		return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2.非递归&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public int maxDepth(TreeNode root) {

		if (root == null) {
			return 0;
		}

		List&amp;lt;TreeNode&amp;gt; tree = new LinkedList&amp;lt;TreeNode&amp;gt;();
		tree.add(root);
		
		int i = 0;
		while (tree.size() != 0) {
			List&amp;lt;TreeNode&amp;gt; tree1 = new LinkedList&amp;lt;TreeNode&amp;gt;();
			for (TreeNode node : tree) {
				tree1.add(node);
			}
			tree.clear();
			for (TreeNode node : tree1) {

				if (node.left != null) {
					tree.add(node.left);
				}

				if (node.right != null) {
					tree.add(node.right);
				}

			}
			i++;
		}
		return i;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一次写markdown，很烂。&lt;br /&gt;
这个题很简单，但是怎么才能优化呢。&lt;br /&gt;
看了一下其他人用C写的速度很快,也是用递归写的。&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Apr 2016 22:23:12 +0800</pubDate>
        <link>http://blog.dantou.cc/main/2016/04/28/LeetCode-maximum-depth-of-binary-tree.html</link>
        <guid isPermaLink="true">http://blog.dantou.cc/main/2016/04/28/LeetCode-maximum-depth-of-binary-tree.html</guid>
        
        
        <category>main</category>
        
      </item>
    
  </channel>
</rss>
